# Documentation

Also known as “how one understands the code”.

## `Cryptography` namespace

### `AgentFlag` enumeration

The namespace should be considered as an enumeration type. The `Type` type is an alias of `unsigned`, which holds the enumeration value. The enumeration is *flagged*, i.e., each bit implies the presence of an agent. `Alice`, `Bob` and `Random` occupy the most insignificant, the second most insignificant and the 18-th most insignificant bit, respectively.

### `Z<p, TBaseType, TPromotedType>` structure template

Represents the quotient ring of Z modulo the ideal generated by `p`. It is often the case that `p` is a prime number, but such requirement is not necessary to instantiate the template. `TBaseType` is an optional argument that allows you to specify another underlying type, if not `uint32_t`. `TPromotedType` is a type in which computation will not cause overflow and defaults to `uint64_t`.

### `ArithmeticCircuits` namespace

This namespace contains everything related to arithmetic circuits.

#### `GateHandle` type

The alias of `unsigned`. Throughout the code, the `Gate`s are stored in an array (or more precisely, a `std::vector`), and they are reference by their index. It should be well noted that the handle is *always* the index of the gate in the `Gates` array. Such attention is important for input gates.

N.B. A gate always belongs to some circuit, and its handle is circuit-specific.

#### `GateKind` enumeration

See `Gate` structure.

#### `Gate` structure

The structure holds the data of a gate.

- `Id` stores the handle of this `Gate`, which should coincide with the index.
- `Kind` is a `GateKind::Type` enumeration, which indicates what kind of gate this `Gate` is.
- `AsXxxKindOfGate` are the fields that occupy the same underlying memory location, among which only the one specified by `Kind` should be used. They are of `XxxKindOfGateData` type, which give further detail about the gate. For example, an input gate has its owner (`Agent`), major and minor indices (`MajorIndex` and `MinorIndex`) stored in `AsInputGate`.

Notes on specific kinds of gates:

- `ConstZero`, `ConstOne` and `ConstMinusOne` are gates that have no input and produce the constant indicated by its name. None of them has further detail.
- `InputGate`, as described earlier.
- `AdditionGate` has `Augend` and `Addend`, handles to the two summands.
- `NegationGate` has `Target`, handle to the gate negated.
- `SubtractionGate` has `Minuend` and `Subtrahend`, handles to the minuend and the subtrahend.
- `MultiplicationGate` has `Multiplier` and `Multiplicand`, handles to the two factors.

#### `GateVisitorCRTP<TVisitor, TRet(TArgs...)>` class template

A helper class template that many would find useful. The template adopts CRTP (curiously recurring template pattern) and is used to implement visitor pattern.

For example, if a visitor `V` visits `Gate`s with extra parameters of type `T1` and type `T2`, and the visiting produces a return value of type `T3`, one might find the following pattern in the code:

```C++
struct V : GateVisitorCRTP<V, T3(T1, T2)>
{
    T3 Visit(Gate *that, T1 arg1, T2 arg2)
    {
        // VisitDispatcher is a private function
        // provided by GateVisitorCRTP that calls
        // the correct function depending on “that”.
        return VisitDispatcher(that, arg1, arg2);
    }
private:
    friend class GateVisitorCRTP<V, T3(T1, T2)>;
    T3 VisitUnmatched(Gate *, T1, T2)
    {
        // Usually there is some error-handling logic.
    }
    T3 VisitInputGate(Gate *that, T1 arg1, T2 arg2)
    {
        auto const &inputGateData = that->AsInputGate;
        // Logic for visiting an input gate.
    }
    // Other VisitXxxKindOfGate logic omitted.
};
```

#### `CircuitCRTP<TC>` structure template

A helper structure that creates `InsertGate` member function for derived structures.

`InsertGate` takes one of the gate data structures as argument and returns the handle to the newly inserted `Gate`. It is assumed that `Gates` is a member of the derived structure with `size` and `push_back` member functions available to `CircuitCRTP<TC>`.

#### `TwoPartyCircuit<TA, TAH>` structure template

This structure holds necessary information for a two-party circuit, where Alice and Bob provide inputs and Alice gets some outputs.

The template arguments are allocators that allows allocating memory for `std::vector`. They are often chosen as the default values. Use default values with empty argument list, i.e., `TwoPartyCircuit<>`.

Members:

- `Gates` is a vector of `Gate`s, in which the indices of `Gate`s are the handles.
- `AliceInputBegin` and `AliceInputEnd` specifies a left-close-right-open interval `[begin, end)` where the input gates of Alice’s reside. In other words, handle `AliceInputBegin`, `AliceInputBegin + 1`, …, `AliceInputEnd - 1` are the handles to all of Alice’s inputs.
- `BobInputBegin` and `BobInputEnd` are similar to those of Alice’s.
- `AliceOutput` is a vector of `GateHandle`s. It stores, in the desired order, handles to the output gates.

#### `Garbled` namespace

This namespace contains everything related to garbled circuits.

##### `KeyPair` structure

Pair of `GateHandle`s in an affine encoding specifying the linear part (`Coefficient`) and the constant part (`Intercept`).

##### `EncodingCircuit<TAG, TAKP, TAKPV, TAH>` structure template

It represents an encoding circuit. The template arguments are allocators. Members:

- `Gates` is a vector of `Gate`s, deciding the handles.
- `Randomness` is a vector of `GateHandle`s, storing the input gates to which a fresh new random value should be supplied when computing the random encoding.
- `OfflineEncoding` is a vector of `GateHandle`s, storing the gates that produce the offline part (constant part) of the encoding.
- `AliceEncoding` is a jagged two-dimensional vector of `KeyPair`s, the k-th vector of which is stores the gates that produce the key pairs of the k-th input from Alice.
- `BobEncoding` is similar to `AliceEncoding`, just for Bob.

##### `DecodingCircuit<TAG, TAH, TAHV>` structure template

It represents a decoding circuit. The template arguments are allocators. Members:

- `Gates` is the old friend that stores all the `Gate`s.
- `OfflineEncoding` is a vector of `GateHandle`s, which are input gates in the decoding circuit and should be fed with the values received from the encoder.
- `AliceEncoding` is a jagged two-dimensional vector of `GateHandle`s, which are input gates in the decoding circuit and should be fed with the results of vector-OLE (suppose Bob does the random encoding).
- `BobEncoding` is similar to `AliceEncoding`, which are input gates in the decoding circuit and should be fed with the encoding for Bob’s part of input.
- `AliceOutput` is a vector of `GateHandle`s, which produce the output for Alice.

##### `CompileToDare` function template

The function has three arguments, a reference `circuit` to `TwoPartyCircuit<blah>`, a reference `encoder` to `EncodingCircuit<blah>` and a reference `decoder` to `DecodingCircuit<blah>`. It compiles `circuit` and stores the resulting pair of circuits in `encoder` and `decoder`.

If `circuit` is well-formed, the compiler guarantees that upon returning from the call:

- `circuit` is lefted unchanged.
- `encoder` and `decoder` are well-formed.
- `encoder.AliceEncoding.size()` equals `circuit.AliceInputEnd - circuit.AliceInputBegin`.
  - Semantically, `encoder.AliceEncoding[i]` stores the key pairs for `circuit.Gates[circuit.AliceInputBegin + i]`.
- `encoder.BobEncoding.size()` equals `circuit.BobInputEnd - circuit.BobInputBegin`.
  - Semantically, `encoder.BobEncoding[i]` stores the key pairs for `circuit.Gates[circuit.BobInputBegin + i]`.
- `decoder.AliceOutput.size()` equals `circuit.AliceOutput.size()`.
- `encoder.OfflineEncoding.size()` equals `decoder.OfflineEncoding.size()`.
- For each `i`, `encoder.AliceEncoding[i].size()` equals `decoder.AliceEncoding[i].size()`.
- For each `i`, `encoder.BobEncoding[i].size()` equals `decoder.BobEncoding[i].size()`.
- `encoder` and `decoder` have the following property: a `Gate` with larger handle depends only on `Gate`s with smaller handle, i.e., the `Gate`s are topologically sorted. (N.B.: The input `circuit` does not have to satisfy this condition.)
- If one supplies random values to random input gates in the `encoder`, computes the encoding, does the linear evaluation and supplies the encoding to `decoder`, `decoder` will produce the outputs that equal the output that would be produced if the same input were supplied to `circuit`.
- The encoding from `encoder` and linear evaluation depends only on the outputs.

##### `_CompilerImpl::CircuitGarbler<blah>` structure template

This structure implements the compiling process. It employs the previously mentioned visitor pattern and uses `GateVisitorCRTP`.

To understand how the process is done, refer to the paper and the comments in the code.
